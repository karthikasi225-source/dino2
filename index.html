<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Malayali Runner - Pro</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { margin: 0; background: #1a1a1a; display: flex; justify-content: center; align-items: center; height: 100vh; user-select: none; overflow: hidden; font-family: sans-serif; }
        canvas { background: linear-gradient(#87ceeb, #e0f7ff); border: 4px solid #333; box-shadow: 0 0 20px rgba(0,0,0,0.5); max-width: 100%; }

        #hint { position: absolute; bottom: 15px; color: white; font-family: monospace; opacity: 0.7; }
        /* Error banner shown when runtimeBroken */
        .error-banner { position: fixed; left: 50%; top: 18px; transform: translateX(-50%); background: rgba(200,40,40,0.95); color: #fff; padding: 12px 14px; border-radius: 8px; z-index: 999; box-shadow: 0 6px 18px rgba(0,0,0,0.4); font-family: monospace; display: none; width: calc(100% - 36px); max-width: 900px; }
        .error-banner pre { white-space: pre-wrap; margin: 6px 0 8px 0; color: #fff; max-height: 120px; overflow:auto; }
        .error-banner .error-actions { display:flex; gap:8px; }
        .error-banner button { background: rgba(255,255,255,0.12); border: none; color: #fff; padding:6px 8px; border-radius:6px; cursor:pointer; }
    </style>
</head>
<body>

<canvas id="game" width="900" height="350"></canvas>
<div id="hint">SPACE / CLICK to Jump</div>

<!-- Mobile Jump Button -->
<button id="jumpBtn" style="position:fixed;right:18px;bottom:18px;padding:18px 22px;border-radius:10px;background:rgba(0,0,0,0.6);color:#fff;border:none;z-index:40;font-weight:700;display:none">JUMP</button>



<!-- Error banner (hidden by default) -->
<div id="errorBanner" class="error-banner" role="alert" aria-live="assertive">
  <div><strong>Runtime error</strong></div>
  <pre id="errorBannerText">(no error)</pre>
  <div class="error-actions">
    <button id="errorCopy">Copy</button>
    <button id="errorResume">Resume</button>
    <button id="errorReload">Reload page</button>
  </div>
</div>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

let gameSpeed = 5;
let gravity = 0.6;
let score = 0;
let highScore = Number(localStorage.getItem("malayaliHighScore") || 0);
let gameOver = false;
let level = 1;

// runtime diagnostics
let assetStatus = {}; // name -> 'pending'|'loaded'|'failed'
let lastError = null;
let fps = 0, lastFpsTime = performance.now(), fpsFrames = 0;
let debugHitbox = false; // show hitboxes disabled by default
let runtimeBroken = false;

// Ensure hitboxes are hidden by default: remove any previously stored debug preference
// (this prevents an old saved 'enabled' value from showing hitboxes unexpectedly).
try {
  localStorage.removeItem('malayaliDebugHitbox');
} catch (e) {}

// Hitbox: separate width & height scales (0.3 .. 1.0). Use setters to clamp + persist.
let hitboxWidth = 0.37; // tuned default
let hitboxHeight = 0.89; // tuned default

function setHitboxWidth(v) {
    if (!isFinite(v)) return;
    hitboxWidth = Math.min(1.0, Math.max(0.3, Number(v)));
    try { localStorage.setItem('malayaliHitboxWidth', hitboxWidth.toString()); } catch (e) {}
}
function setHitboxHeight(v) {
    if (!isFinite(v)) return;
    hitboxHeight = Math.min(1.0, Math.max(0.3, Number(v)));
    try { localStorage.setItem('malayaliHitboxHeight', hitboxHeight.toString()); } catch (e) {}
}

// Legacy compatibility: migrate single-scale legacy value to both width & height if necessary
try {
  const hbWRaw = localStorage.getItem('malayaliHitboxWidth');
  const hbHRaw = localStorage.getItem('malayaliHitboxHeight');
  const hbRaw = localStorage.getItem('malayaliHitboxScale'); // legacy
  if (hbWRaw !== null) setHitboxWidth(Number(hbWRaw));
  if (hbHRaw !== null) setHitboxHeight(Number(hbHRaw));
  if (hbRaw !== null && hbWRaw === null && hbHRaw === null) {
      setHitboxWidth(Number(hbRaw));
      setHitboxHeight(Number(hbRaw));
  }
} catch (e) {}

// Sprite animation state (two-frame running)
let spriteTick = 0;
let spriteFrame = 0;

// Player sprite frames
const playerSprites = [new Image(), new Image()];
playerSprites[0].src = './spriteframe1.png';
playerSprites[1].src = './spriteframe2.png';

// ================= PLAYER (animated sprite)
const player = {
    x: 80,
    y: 260,
    // default size; will be adjusted at spawn if sprite info available
    w: 48,
    h: 60,
    vy: 0,
    jumping: false
};

// Player hitbox helper — returns a centered, scaled collision box. Lower scale = tighter hitbox.
function getPlayerHitbox() {
    const wscale = isFinite(hitboxWidth) ? hitboxWidth : 0.37;
    const hscale = isFinite(hitboxHeight) ? hitboxHeight : 0.89;
    const hbW = Math.max(4, Math.round(player.w * wscale));
    const hbH = Math.max(4, Math.round(player.h * hscale));
    const hbX = Math.round(player.x + (player.w - hbW) / 2);
    // anchor the box near the player's feet so jumps still clear obstacles
    const hbY = Math.round(player.y + (player.h - hbH));
    return { x: hbX, y: hbY, w: hbW, h: hbH };
}

// ================= OBSTACLES =================
let obstacles = [];
let obstacleTimer = 0;
let obstacleInterval = 220; // base interval, reduced with level (increased to lower obstacle density further) -- larger interval = fewer spawns

// ================= CLOUDS =================
let clouds = [
    { x: 300, y: 60, s: 0.5 },
    { x: 700, y: 90, s: 0.8 },
    { x: 100, y: 40, s: 0.3 }
];

// Obstacle sprites (ensure these files exist relative to the HTML file, e.g. put them in an `img/` folder)
const obstacleSprites = [new Image(), new Image()];
obstacleSprites[0].src = './obstacle1.png';
obstacleSprites[1].src = './obstacle2.png';

// --- Asset monitoring / diagnostics helpers ---
function monitorImage(img, name) {
    assetStatus[name] = 'pending';
    img._assetName = name;
    img.addEventListener('load', () => { assetStatus[name] = 'loaded'; });
    img.addEventListener('error', () => { assetStatus[name] = 'failed'; });
    // mark as failed if still pending after a timeout
    setTimeout(() => { if (assetStatus[name] === 'pending') assetStatus[name] = 'failed'; }, 2500);
}

monitorImage(playerSprites[0], 'player-frame-0');
monitorImage(playerSprites[1], 'player-frame-1');
monitorImage(obstacleSprites[0], 'obstacle-0');
monitorImage(obstacleSprites[1], 'obstacle-1');

window.addEventListener('error', e => {
    lastError = (e && e.message) ? (e.message + ' @ ' + (e.filename || '') + ':' + (e.lineno || '')) : String(e);
    console.error(e);
});
window.addEventListener('unhandledrejection', e => {
    lastError = 'Unhandled promise rejection: ' + (e.reason && e.reason.message ? e.reason.message : String(e.reason));
    console.error(e);
});



// Error banner helpers
function showErrorBanner(errText) {
    try {
        const banner = document.getElementById('errorBanner');
        const pre = document.getElementById('errorBannerText');
        if (!banner || !pre) return;
        pre.textContent = String(errText || '(no details)');
        banner.style.display = 'block';
        // wire buttons once
        const copyBtn = document.getElementById('errorCopy');
        const resumeBtn = document.getElementById('errorResume');
        const reloadBtn = document.getElementById('errorReload');
        if (copyBtn && !copyBtn._wired) {
            copyBtn.addEventListener('click', () => { try { navigator.clipboard.writeText(pre.textContent); copyBtn.textContent = 'Copied'; setTimeout(()=>copyBtn.textContent='Copy',1500);}catch(e){console.warn(e)} });
            copyBtn._wired = true;
        }
        if (resumeBtn && !resumeBtn._wired) {
            resumeBtn.addEventListener('click', () => { runtimeBroken = false; hideErrorBanner(); });
            resumeBtn._wired = true;
        }
        if (reloadBtn && !reloadBtn._wired) {
            reloadBtn.addEventListener('click', () => { location.reload(); });
            reloadBtn._wired = true;
        }
    } catch (e) { console.error(e); }
}
function hideErrorBanner(){ try{ const b = document.getElementById('errorBanner'); if(b) b.style.display='none'; }catch(e){} }

// If a stored lastError exists on load and panel visible, show it
setTimeout(() => { if (lastError) showErrorBanner(lastError); }, 200);

// Audio (synthesized)
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx = null;
function ensureAudio(){ if(!audioCtx) audioCtx = new AudioCtx(); }
function playJumpSound(){
  ensureAudio();
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = 'sine'; o.frequency.value = 350;
  g.gain.value = 0.0001;
  o.connect(g); g.connect(audioCtx.destination);
  const now = audioCtx.currentTime;
  g.gain.setValueAtTime(0.0001, now);
  g.gain.exponentialRampToValueAtTime(0.2, now + 0.02);
  g.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
  o.start(now); o.stop(now + 0.26);
}

function playCrashSound(){
  ensureAudio();
  const bufferSize = audioCtx.sampleRate * 0.25;
  const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
  const data = buffer.getChannelData(0);
  for(let i=0;i<bufferSize;i++) data[i] = (Math.random()*2-1) * Math.exp(-i/3000);
  const src = audioCtx.createBufferSource();
  src.buffer = buffer; src.connect(audioCtx.destination);
  src.start();
}

// ================= CONTROLS =================
function jump() {
    if (!player.jumping && !gameOver) {
        player.vy = -12;
        player.jumping = true;
        playJumpSound();
    }
    if (gameOver) resetGame();
}

document.addEventListener("keydown", e => {
    if (e.code === "Space" || e.code === "ArrowUp") { e.preventDefault(); jump(); }

});
canvas.addEventListener("mousedown", e => { e.preventDefault(); jump(); });
canvas.addEventListener("touchstart", e => { e.preventDefault(); jump(); }, {passive:false});

// Mobile jump button
const jumpBtn = document.getElementById('jumpBtn');
function updateMobileButton(){
  if(window.innerWidth < 600){ jumpBtn.style.display = 'block'; } else jumpBtn.style.display = 'none';
}
jumpBtn.addEventListener('touchstart', e => { e.preventDefault(); jump(); }, {passive:false});
jumpBtn.addEventListener('mousedown', e => { e.preventDefault(); jump(); });
window.addEventListener('resize', updateMobileButton);
updateMobileButton();
// Player customization UI removed — using defaults (no runtime sprite swapping or background removal)



// ================= RESET =================
function resetGame() {
    obstacles = [];
    score = 0;
    gameSpeed = 5;
    gameOver = false;
    player.y = 260;
    player.vy = 0;
    level = 1;
    obstacleInterval = 80;
}

// ================= UPDATE =================
function update() {
    if (gameOver) return;

    // Player physics
    player.vy += gravity;
    player.y += player.vy;

    if (player.y >= 260) {
        player.y = 260;
        player.vy = 0;
        player.jumping = false;
    }

    // Obstacle Spawning (Randomized gaps, min gap enforcement, max 2 on screen)
    obstacleTimer++;
    // increase spawn threshold so on average fewer obstacles
    const spawnThreshold = Math.max(80, obstacleInterval - level*6);

    // do not spawn if already 2 or more obstacles on screen
    const onScreen = obstacles.filter(o => o.x + o.w > 0).length;
    if (onScreen >= 2) {
        obstacleTimer = 0; // postpone spawn
    }

    if (obstacleTimer > (Math.random() * (spawnThreshold - 40) + 40)) {
        const sizeBase = 20 + Math.random() * 30;
        // randomized gap distribution (mixture): uniform, clustered small, and long-tail large gaps
        const minGap = 150; // hard minimum distance between obstacles (increased)
        const maxGapBase = Math.max(minGap + 180, 480 - level * 10);
        let gap;
        const r = Math.random();
        if (r < 0.6) {
            // 60% uniform between minGap and maxGapBase
            gap = Math.floor(minGap + Math.random() * (maxGapBase - minGap));
        } else if (r < 0.9) {
            // 30% small cluster: closer obstacles within half the range
            gap = Math.floor(minGap + Math.random() * ((maxGapBase - minGap) / 2));
        } else {
            // 10% long-tail: favors very large gaps (use power distribution)
            gap = Math.floor(minGap + Math.pow(Math.random(), 0.3) * (maxGapBase * 2 - minGap));
        }
        // occasional rare huge gap to create long runs without obstacles
        if (Math.random() < 0.05) gap += Math.floor(200 + Math.random() * 400);

        let xPos = canvas.width + gap;
        if (obstacles.length) {
            const last = obstacles[obstacles.length - 1];
            const minX = last.x + last.w + minGap;
            if (xPos < minX) xPos = minX;
        }

        // choose a sprite index and try to spawn using sprite if available; otherwise fall back to placeholder
        const spriteIdx = Math.floor(Math.random() * obstacleSprites.length);
        const img = obstacleSprites[spriteIdx];
        const imgReady = img && img.complete && img.naturalWidth;
        const anySpriteReady = obstacleSprites.some(s => s && s.complete && s.naturalWidth);
        if (!imgReady && anySpriteReady) {
            // some sprites are ready but not this one - try again later
            obstacleTimer = 0;
        } else {
            if (imgReady) {
                // compute size based on sprite aspect ratio when available
                let hVal = 40 + Math.random() * 40; // height between ~40-80
                let wVal = Math.round(hVal * (img.naturalWidth / img.naturalHeight));
                obstacles.push({ x: xPos, y: 320 - hVal, w: wVal, h: hVal, sprite: spriteIdx });
            } else {
                // no sprites available (failed or not loaded) - spawn placeholder obstacle instead
                const hVal = 40 + Math.random() * 40;
                const wVal = Math.round(hVal * 0.7);
                obstacles.push({ x: xPos, y: 320 - hVal, w: wVal, h: hVal, sprite: null });
            }
            obstacleTimer = 0;
        }
    }

    obstacles.forEach(o => o.x -= gameSpeed);
    obstacles = obstacles.filter(o => o.x + o.w > -50);

    // Collision (using configurable player hitbox)
    const ph = getPlayerHitbox();
    obstacles.forEach(o => {
        const ox = o.x + 6;
        const oy = o.y + 6;
        const ow = Math.max(0, o.w - 12);
        const oh = Math.max(0, o.h - 12);
        if (
            ph.x < ox + ow &&
            ph.x + ph.w > ox &&
            ph.y < oy + oh &&
            ph.y + ph.h > oy
        ) {
            gameOver = true;
            playCrashSound();
            if (score > highScore) {
                highScore = score;
                localStorage.setItem("malayaliHighScore", highScore);
            }
        }
    });

    // Clouds
    clouds.forEach(c => {
        c.x -= c.s;
        if (c.x < -100) c.x = canvas.width + 100;
    });

    score++;

    // Level progression
    const newLevel = Math.floor(score / 1000) + 1;
    if (newLevel > level) {
        level = newLevel;
        gameSpeed += 0.8; // bump speed on level up
    }
}

// ================= DRAWING FUNCTIONS (sprite animation) =================
function drawGround() {
    // Road
    ctx.fillStyle = "#708090";
    ctx.fillRect(0, 320, canvas.width, 30);
    // Grass line
    ctx.fillStyle = "#2e8b57";
    ctx.fillRect(0, 315, canvas.width, 5);
} 

function drawPlayer() {
    // Animate running frames (legs alternate)
    spriteTick++;
    if (spriteTick > 6) { spriteFrame = (spriteFrame + 1) % 2; spriteTick = 0; }

    // If player sprite frames are ready, draw them; otherwise fallback to block
    const frameImg = playerSprites[spriteFrame];
    if (frameImg && frameImg.complete && frameImg.naturalWidth) {
        // adjust player size to sprite aspect ratio once if needed
        if (!player._sizeAdjusted) {
            const targetH = player.h; // keep existing height
            player.h = targetH;
            player.w = Math.round(targetH * (frameImg.naturalWidth / frameImg.naturalHeight));
            player._sizeAdjusted = true;
        }

        // Draw sprite (if jumping, draw the same frame but slightly higher; could use separate jump frame)
        let drawY = player.y;
        if (player.jumping) drawY = player.y - 6; // small lift for jump
        ctx.drawImage(frameImg, Math.round(player.x), Math.round(drawY), Math.round(player.w), Math.round(player.h));

        // Optional: draw small shadow
        ctx.fillStyle = 'rgba(0,0,0,0.12)';
        ctx.fillRect(player.x + 6, player.y + player.h - 6, player.w - 12, 6);
    } else {
        // fallback block (previous look)
        ctx.fillStyle = '#ffcc80';
        ctx.fillRect(player.x, player.y, player.w, player.h);
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(player.x, player.y + 30, player.w, 30);
    }

    // debug: draw player hitbox when enabled
    if (debugHitbox) {
        try {
            const ph = getPlayerHitbox();
            ctx.save();
            ctx.strokeStyle = 'rgba(0,200,80,0.95)';
            ctx.lineWidth = 2;
            ctx.strokeRect(ph.x, ph.y, ph.w, ph.h);
            ctx.restore();
        } catch (e) { /* ignore */ }
    }

}

function drawObstacles() {
    obstacles.forEach(o => {
        // Draw only sprite-based obstacles (no coconut fallback)
        if (o.sprite != null && obstacleSprites[o.sprite] && obstacleSprites[o.sprite].complete && obstacleSprites[o.sprite].naturalWidth) {
            ctx.drawImage(obstacleSprites[o.sprite], Math.round(o.x), Math.round(o.y), Math.round(o.w), Math.round(o.h));
        } else {
            // If for some reason the sprite isn't ready, draw a neutral rectangle placeholder
            ctx.fillStyle = "#444";
            ctx.fillRect(Math.round(o.x), Math.round(o.y), Math.round(o.w), Math.round(o.h));
        }

        if (debugHitbox) {
            const ox = Math.round(o.x + 6);
            const oy = Math.round(o.y + 6);
            const ow = Math.round(Math.max(0, o.w - 12));
            const oh = Math.round(Math.max(0, o.h - 12));
            ctx.save();
            ctx.strokeStyle = 'rgba(255,165,0,0.85)';
            ctx.lineWidth = 2;
            ctx.strokeRect(ox, oy, ow, oh);
            ctx.restore();
        }

    });
}

function drawClouds() {
    ctx.fillStyle = "rgba(255, 255, 255, 0.85)";
    clouds.forEach(c => {
        ctx.beginPath();
        ctx.arc(c.x, c.y, 20, 0, Math.PI * 2);
        ctx.arc(c.x + 25, c.y + 5, 25, 0, Math.PI * 2);
        ctx.arc(c.x + 55, c.y, 20, 0, Math.PI * 2);
        ctx.fill();
    });
}

function drawUI() {
    ctx.fillStyle = "#333";
    ctx.font = "bold 18px monospace";
    ctx.fillText("SCORE: " + score, 20, 35);
    ctx.fillText("BEST:  " + highScore, 20, 60);
    ctx.fillText("LEVEL: " + level, 20, 88);



    if (gameOver) {
        ctx.fillStyle = "rgba(0,0,0,0.75)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = "#fff";
        ctx.textAlign = "center";
        ctx.font = "bold 48px monospace";
        ctx.fillText("GAME OVER", canvas.width / 2, 140);
        
        ctx.font = "20px monospace";
        ctx.fillText("Score: " + score, canvas.width / 2, 180);
        ctx.fillText("Press SPACE or Tap to try again", canvas.width / 2, 220);
        ctx.textAlign = "left"; // Reset alignment
    }
}

// ================= GAME LOOP =================
function loop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    drawClouds();
    drawGround();
    drawPlayer();
    drawObstacles();
    drawUI();



    // Run update safely; if it throws repeatedly we stop calling it and show the error
    if (!runtimeBroken) {
        try {
            update();
        } catch (err) {
            lastError = (err && err.message) ? err.message : String(err);
            console.error('Runtime error in update():', err);
            runtimeBroken = true;
            try { showErrorBanner(lastError); } catch (e) { console.error(e); }
        }
    }

    // FPS tracking
    fpsFrames++;
    const now = performance.now();
    if (now - lastFpsTime >= 1000) {
        fps = Math.round((fpsFrames * 1000) / (now - lastFpsTime));
        fpsFrames = 0;
        lastFpsTime = now;
    }

    requestAnimationFrame(loop);
}

// Start the loop
resetGame();
loop();
</script>
</body>
</html>
